use std::env;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::net::SocketAddr;
use std::option;
use std::path::Path;
use std::process::Stdio;
use std::str::FromStr;
use std::time::Duration;
use std::time::SystemTime;
use std::time::UNIX_EPOCH;

use clap::Parser;
use clap::Subcommand;
use const_format::concatcp;
use controller::bootstrap::ControllerCommand;
use controller::bootstrap::RunCommand;
use controller::bootstrap::WORLD_LABEL_PREFIX;
use fbwhoami::FbWhoAmI;
use futures::future::TryJoinAll;
use hpc_scheduler_constants::MastReplyFileErrorCode;
use hyperactor::channel::ChannelAddr;
use hyperactor::id;
use hyperactor::reference::ActorId;
use hyperactor::reference::WorldId;
use hyperactor::serde_json;
use hyperactor_meta_lib::system_resolution::SMCClient;
use hyperactor_meta_lib::system_resolution::canonicalize_hostname;
use hyperactor_multiprocess::System;
use hyperactor_multiprocess::system_actor;
use hyperactor_multiprocess::system_actor::SystemMessageClient;
use hyperactor_telemetry::env::Env;
use tokio::process::Command;

// These environment variables should be available on every MAST host.
static MAST_HPC_TASK_GROUP_HOSTNAMES: &str = "MAST_HPC_TASK_GROUP_HOSTNAMES";
static MAST_HPC_JOB_NAME: &str = "MAST_HPC_JOB_NAME";
static MAST_HPC_TASK_GROUP_ATTEMPT_EPOCH: &str = "MAST_HPC_TASK_GROUP_ATTEMPT_EPOCH";
static MAST_HPC_TASK_FAILURE_REPLY_FILE: &str = "MAST_HPC_TASK_FAILURE_REPLY_FILE";
// Env variable injected during MAST job creation to provide the name
// of SMC tier to query for system address.
// See: https://fburl.com/code/ialyz1nb
static MONARCH_SMC_SYSTEM_TIER_NAME_ENV: &str = "MONARCH_SMC_SYSTEM_TIER_NAME";
// Optionally contains a path to a file generated by the xlformers rank assignment script at job launch.
// This file contains a list of hostnames for the task group that may be in a different
// order than MAST_HPC_TASK_GROUP_HOSTNAMES.
static TORCH_ELASTIC_CUSTOM_HOSTNAMES_LIST_FILE: &str = "TORCH_ELASTIC_CUSTOM_HOSTNAMES_LIST_FILE";
// Override system address read from environment variable. Used for environment like MAST emulator
static OVERRIDE_SYSTEM_ADDR: &str = "OVERRIDE_SYSTEM_ADDR";

/// Label indicating the ip address of the actor's host.
pub static LABEL_NAME_IP_NAME: &str = concatcp!(WORLD_LABEL_PREFIX, "ipaddr");
/// Label indicating the host_name of the actor's host.
pub static LABEL_NAME_HOST_NAME: &str = concatcp!(WORLD_LABEL_PREFIX, "hostname");

/// How long to wait for the system to shutdown before we kill it.
static SHUTDOWN_TIMEOUT_SECS: u64 = 60;

#[derive(Subcommand)]
enum MastSubcommand {
    /// Start the monarch core task group system process and main script.
    System(SystemArgs),
    /// Start the worker task group(s) setup of controller and woker worlds.
    Worker(WorkerArgs),
}

#[derive(Parser)]
struct SystemArgs {
    /// The system supervision update timeout in seconds.
    #[arg(long, default_value_t = 30)]
    supervision_update_timeout_in_sec: u64,

    /// Evict a world if it has been unhealthy for this many seconds.
    #[arg(long, default_value_t = 10)]
    world_eviction_timeout_in_sec: u64,

    /// The shell command to run for the main script. This could
    /// be, e.g., "/path/to/bash.sh", "python /path/to/python.py --arg1 --arg2",
    /// etc.
    #[arg(
        long,
        trailing_var_arg = true,
        num_args = 1..,
        allow_hyphen_values = true,
        value_terminator = "--"
    )]
    main_script: Option<Vec<String>>,
}

#[derive(Parser)]
struct WorkerArgs {
    /// The world to create
    #[arg(long)]
    world: WorldId,

    /// The host world to create
    #[arg(long)]
    host_world: WorldId,

    /// The program to execute for each process.
    #[arg(long)]
    program: String,

    /// The number of processes per host.
    #[arg(short, long, default_value_t = 8)]
    num_procs_per_host: usize,

    /// The proc supervision update interval in seconds.
    #[arg(long, default_value_t = 2)]
    supervision_update_interval_in_sec: u64,

    /// The controller supervision query timeout in seconds.
    #[arg(long, default_value_t = 2)]
    supervision_query_interval_in_sec: u64,

    /// The worker progress check interval in seconds.
    #[arg(long, default_value_t = 10)]
    worker_progress_check_interval_in_sec: u64,

    /// The timeout allowed for each operation in seconds.
    #[arg(long, default_value_t = 120)]
    operation_timeout_in_sec: u64,

    /// The number of operations invoked before we proactively check worker progress. If a large number
    /// of operations are invoked all at once, it is expected that it will take a while for all operations
    /// to complete so we want to inject progress requests at a higher frequency to check if we are making progress  
    #[arg(long, default_value_t = 100)]
    operations_per_worker_progress_request: u64,

    /// If the controller should propagate a failure to the client if the workers become stuck.
    #[arg(long, default_value_t = false)]
    pub fail_on_worker_timeout: bool,

    /// The controller actor id to connect.
    #[arg(long, default_value_t = id!(controller[0].controller[0]))]
    controller_actor_id: ActorId,

    /// The worker name.
    #[arg(long, default_value_t = String::from("worker"))]
    worker_name: String,

    /// If to launch the workers for CPU-only devices.
    #[arg(long, default_value_t = false)]
    pub is_cpu_worker: bool,
}

#[derive(Parser)]
#[command()]
struct Cli {
    /// The system port to use when SMC is not used. This is kept for backward
    /// compatibility and the possibilty to bypass SMC in the future.
    #[arg(short, long, default_value_t = 29500)]
    system_port: u16,

    #[arg(long, env = MAST_HPC_JOB_NAME)]
    mast_hpc_job_name: Option<String>,

    #[arg(long, env = MONARCH_SMC_SYSTEM_TIER_NAME_ENV)]
    monarch_smc_system_tier_name: Option<String>,

    /// The total number of hosts in the system. This argument
    /// is required because the main script is currently in a
    /// separate task group from the workers and therefore doesn't
    /// have access to the list of worker hosts at bootstrap.
    #[arg(long)]
    num_hosts: usize,

    #[command(subcommand)]
    command: MastSubcommand,
}

/// The main entry point of hyperactor for MAST. To fast validate if it works locally,
/// run the following command:
/// ```ignore
///  # first start the system process:
///  MAST_HPC_TASK_GROUP_HOSTNAMES="$(hostname)" \
///     buck2 run //monarch/hyperactor_meta \
///     -- --num-hosts=1 system &
///  # then start the controller and worker processes:
///  MAST_HPC_TASK_GROUP_HOSTNAMES="$(hostname)" \
///     buck2 run //monarch/hyperactor_meta \
///     -- --num-hosts=1 worker --world test --host-world testhost --program <PROGRAM_NAME>
/// ```
/// Note: world and host_world need to have the same prefix
/// It will launch a system, a controller, and a host actor on the same host.
#[fbinit::main]
async fn main(fb: fbinit::FacebookInit) -> Result<(), anyhow::Error> {
    let global_args = Cli::parse();

    if let Some(ref job_name) = global_args.mast_hpc_job_name {
        std::env::set_var(
            hyperactor_telemetry::env::HYPERACTOR_EXECUTION_ID_ENV,
            job_name.clone(),
        );
    }

    // Set up hyperactor process environment.
    hyperactor::initialize();

    // If TORCH_ELASTIC_CUSTOM_HOSTNAMES_LIST_FILE is set, try to load the hostnames from the
    // provided path. If this fails, terminate with an error. If the environment variable isn't set,
    // try to load the hosts from the MAST_HPC_TASK_GROUP_HOSTNAMES environment variable.
    let hosts = match env::var(TORCH_ELASTIC_CUSTOM_HOSTNAMES_LIST_FILE) {
        Ok(val) => get_hosts_from_file(Path::new(&val))?,
        Err(env::VarError::NotPresent) => get_hosts_from_env()?,
        Err(err) => return Err(anyhow::anyhow!("getting hostnames failed with {:?}", err)),
    };
    assert!(!hosts.is_empty(), "found no host");

    let current_host: String = canonicalize_hostname(
        hostname::get()
            .ok()
            .and_then(|hostname| hostname.into_string().ok())
            .expect("failed to retrieve hostname")
            .as_str(),
    );
    tracing::info!("current host is {}", current_host);

    let num_hosts = global_args.num_hosts;
    tracing::info!("num hosts: {}", num_hosts);

    let mut handles = Vec::new();
    match global_args.command {
        MastSubcommand::System(args) => {
            tracing::info!("starting monarch system");

            if hosts.len() != 1 {
                return Err(anyhow::anyhow!(
                    "system should be running in a single host task group; found {}",
                    hosts.len()
                ));
            }

            // system listens on inaddr_any to allow for TW health checks on localhost.
            // Directly get system address if it is local mast emulator setup.
            let system_addr = try_get_system_address_from_emulator(global_args.system_port)
                .unwrap_or(ChannelAddr::MetaTls(
                    std::net::Ipv6Addr::UNSPECIFIED.to_string(),
                    global_args.system_port,
                ));
            tracing::info!("listening on address {}", system_addr);
            handles.push(controller::bootstrap::run(RunCommand::System {
                system_addr: system_addr.to_string(),
                supervision_update_timeout_in_sec: args.supervision_update_timeout_in_sec,
                world_eviction_timeout_in_sec: args.world_eviction_timeout_in_sec,
            })?);

            // For the main traing script we use fq system address as sent to workers for easier
            // readability in its logs.
            // Workaround for local mast emulator to use IP address directly.
            let system_addr =
                try_get_system_address_from_emulator(global_args.system_port).unwrap_or(
                    ChannelAddr::MetaTls(current_host.clone(), global_args.system_port),
                );
            // If a main script was provided, run it on the first host. This is temporary.
            // Eventually the main script will run on its own host in its own task group (TODO(T213708265)).
            // This also currently only supports a 1:1 client-mesh mapping, but very soon
            // we will want to support 1:many.
            if let Some(command) = args.main_script {
                if current_host.contains(&hosts[0]) {
                    handles.push(tokio::spawn(spawn_main_script(
                        system_addr,
                        num_hosts,
                        command,
                    )));
                }
            }
        }
        MastSubcommand::Worker(args) => {
            tracing::info!("starting monarch worker");
            tracing::info!("launching hyperactor on {} hosts", hosts.len());
            tracing::info!("controller actor: {}", hosts[0]);
            tracing::info!("host actors: {}", hosts.join(","));

            // We need system's address for other actors to connect to it.
            let system_addr = get_system_address(
                fb,
                global_args.system_port,
                global_args.monarch_smc_system_tier_name,
                &hosts,
            )
            .await?;
            tracing::info!("system address is {}", system_addr);

            // Make sure the current host is in the list of hosts.
            // The hostname is in format of XXX.HOSTNAME.tw.fbinfra.net
            // We need to match the hostname without the prefix and suffix.
            let host_rank = hosts
                .iter()
                .position(|host| current_host.contains(host))
                .unwrap_or_else(|| {
                    panic!(
                        "current host {} not found in hosts {:?}",
                        current_host, hosts
                    )
                });

            let num_procs = num_hosts * args.num_procs_per_host;

            // Spawn the controller actor
            if current_host.contains(&hosts[0]) {
                handles.push(controller::bootstrap::run(RunCommand::Controller(
                    ControllerCommand {
                        worker_world: world_with_epoch(&args.world).to_string(),
                        system_addr: system_addr.to_string(),
                        controller_actor_id: world_with_epoch(&WorldId(
                            args.controller_actor_id.world_name().to_string(),
                        ))
                        .proc_id(args.controller_actor_id.rank())
                        .actor_id(
                            args.controller_actor_id.name(),
                            args.controller_actor_id.pid(),
                        )
                        .to_string(),
                        world_size: num_procs,
                        num_procs_per_host: args.num_procs_per_host,
                        worker_name: args.worker_name,
                        program: Some(args.program),
                        supervision_query_interval_in_sec: args.supervision_query_interval_in_sec,
                        supervision_update_interval_in_sec: args.supervision_update_interval_in_sec,
                        worker_progress_check_interval_in_sec: args
                            .worker_progress_check_interval_in_sec,
                        operation_timeout_in_sec: args.operation_timeout_in_sec,
                        operations_per_worker_progress_request: args
                            .operations_per_worker_progress_request,
                        fail_on_worker_timeout: args.fail_on_worker_timeout,
                        is_cpu_worker: args.is_cpu_worker,
                        extra_proc_labels: Some(get_extra_labels(current_host.clone())),
                    },
                ))?);
            }

            // Spawn host actor
            handles.push(controller::bootstrap::run(RunCommand::Host {
                system_addr: system_addr.to_string(),
                host_world: world_with_epoch(&args.host_world).to_string(),
                host_rank,
                supervision_update_interval_in_sec: args.supervision_update_interval_in_sec,
            })?);
        }
    }

    handles.into_iter().collect::<TryJoinAll<_>>().await?;

    Ok(())
}

#[tracing::instrument(skip_all)]
async fn spawn_main_script(
    system_addr: ChannelAddr,
    num_hosts: usize,
    command: Vec<String>,
) -> Result<(), anyhow::Error> {
    tracing::info!("spawning main script: {:?}", command.join(" "));

    let mut child = Command::new(&command[0]);
    if command.len() > 1 {
        child.args(&command[1..]);
    }

    let child = child
        .env("HYPERACTOR_SYSTEM_ADDR", system_addr.to_string())
        .env("MONARCH_NUM_HOSTS_PER_TASK_GROUP", num_hosts.to_string())
        .stdin(Stdio::null())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn();

    let output = match child {
        Err(err) => {
            let error_message = format!("failed spawning main script with error {}", err);
            tracing::error!(error_message);
            write_error_to_reply_file_and_abort(
                &format!("{error_message}; check MAST logs for more details"),
                MastReplyFileErrorCode::NON_RETRYABLE_FAILURE.0,
            );
            return Err(err.into());
        }
        Ok(child) => child.wait_with_output().await,
    };

    let output = match output {
        Err(err) => {
            let error_message = format!("failed awaiting main script process with error {:?}", err);
            tracing::error!(error_message);
            write_error_to_reply_file_and_abort(
                &format!("{error_message}; check MAST logs for more details"),
                MastReplyFileErrorCode::NON_RETRYABLE_FAILURE.0,
            );

            return Err(err.into());
        }
        Ok(output) => output,
    };

    if !output.status.success() {
        let error_message = format!(
            "main script failed with exit code {}",
            output
                .status
                .code()
                .map_or("unknown".to_string(), |c| c.to_string())
        );
        tracing::error!(error_message);
        write_error_to_reply_file_and_abort(
            // TODO: we need to find a way to tunnel the full stacktrace to the reply file.
            &format!("{error_message}; check MAST logs for more details"),
            // TODO: we need to expose the actual exit code to indicate retryable vs permanent errors.
            MastReplyFileErrorCode::JOB_RESTART_SCOPE_ESCALATION.0,
        );

        Err(anyhow::anyhow!(error_message))
    } else {
        tracing::info!("main script completed successfully.");

        let mut system = System::new(system_addr);
        let mailbox = system.attach().await?;
        let (tx, rx) = mailbox.open_once_port();
        system_actor::SYSTEM_ACTOR_REF
            .stop(
                &mailbox,
                option::Option::None,
                Duration::from_secs(SHUTDOWN_TIMEOUT_SECS),
                tx.bind(),
            )
            .await?;
        rx.recv().await?;

        tracing::info!("system shutdown successful.");

        Ok(())
    }
}

fn get_tcp_channel_addr(host: std::net::Ipv6Addr, port: u16) -> ChannelAddr {
    tracing::info!("read system IP address {}", host);
    ChannelAddr::Tcp(SocketAddr::V6(std::net::SocketAddrV6::new(
        host, port, 0, 0,
    )))
}

/// Try to directly get a system address if we are in emulator setup.
fn try_get_system_address_from_emulator(system_port: u16) -> Option<ChannelAddr> {
    let sys_addr = env::var(OVERRIDE_SYSTEM_ADDR).ok();
    assert!(
        (Env::current() == Env::MastEmulator) ^ sys_addr.is_none(),
        "Override system address should only be set iff Env is Mast Emulator"
    );

    sys_addr
        .and_then(|host_str| std::net::Ipv6Addr::from_str(&host_str).ok())
        .map(|host| get_tcp_channel_addr(host, system_port))
}

// Obtains system address based on current configuration.
// The following are the scenarios handled:
// 0. If the env var MAST_EMULATOR_SYSTEM_IPV6 is set, this triggers a temporary
// workaround to read the system IP address directly from the env var. This is used
// for the local mast simulator's integration with the rust backend.
// 1. If the env var MONARCH_SMC_SYSTEM_TIER_NAME is set, then the system address is
//    obtained from the SMC tier specified by the env var. This indicates that system
//    is running in a separate task group in MAST with a single host.
// 2. If the env var is not set, then the system address is obtained from
//    MAST_HPC_TASK_GROUP_HOSTNAMES[0]. This indicates that system is running in the same
//    task group as the workers, or is running outside of MAST for testing.
async fn get_system_address(
    fb: fbinit::FacebookInit,
    default_system_port: u16,
    smc_system_tier_name: Option<String>,
    hosts: &[String],
) -> Result<ChannelAddr, anyhow::Error> {
    if Env::current() == Env::MastEmulator {
        assert!(
            env::var(OVERRIDE_SYSTEM_ADDR).is_ok(),
            "Override system address must be set for Mast Emulator"
        );

        let host_str = env::var(OVERRIDE_SYSTEM_ADDR).unwrap();

        match std::net::Ipv6Addr::from_str(&host_str) {
            Ok(host) => Ok(get_tcp_channel_addr(host, default_system_port)),
            Err(err) => Err(anyhow::anyhow!(
                "failed to parse IPv6 address {}:{}. error: {}    ",
                host_str,
                default_system_port,
                err
            )),
        }
    } else if let Some(tier) = smc_system_tier_name {
        tracing::info!("reading SMC tier {} for system address", tier);
        let (host, port) = SMCClient::new(fb, tier)?.get_system_address().await?;
        Ok(ChannelAddr::MetaTls(canonicalize_hostname(&host), port))
    } else {
        tracing::info!(
            "reading {} for system address",
            MAST_HPC_TASK_GROUP_HOSTNAMES
        );
        let host = hosts[0].clone();
        let port = default_system_port;
        Ok(ChannelAddr::MetaTls(canonicalize_hostname(&host), port))
    }
}

fn get_hosts_from_env() -> Result<Vec<String>, anyhow::Error> {
    let hosts: Vec<String> = env::var(MAST_HPC_TASK_GROUP_HOSTNAMES)?
        .split(',')
        .map(canonicalize_hostname)
        .collect();
    if hosts.is_empty() {
        return Err(anyhow::anyhow!(
            "{} is empty",
            MAST_HPC_TASK_GROUP_HOSTNAMES
        ));
    }
    Ok(hosts)
}

fn get_hosts_from_file(file_path: &Path) -> Result<Vec<String>, anyhow::Error> {
    let contents = fs::read_to_string(file_path)?;
    let json: serde_json::Value = serde_json::from_str(&contents)?;
    let hosts: Vec<String> = json["hostnames"]
        .as_array()
        .ok_or_else(|| anyhow::anyhow!("invalid JSON format"))?
        .iter()
        .map(|x| canonicalize_hostname(x.as_str().unwrap()).to_string())
        .collect();

    if hosts.is_empty() {
        return Err(anyhow::anyhow!(
            "{} is empty",
            TORCH_ELASTIC_CUSTOM_HOSTNAMES_LIST_FILE
        ));
    }

    Ok(hosts)
}

/// Create a session id for controller and worker. It is needed to separate world
/// before and after a MAST task group recovery.
fn world_with_epoch(world_id: &WorldId) -> WorldId {
    if let Ok(epoch) = env::var(MAST_HPC_TASK_GROUP_ATTEMPT_EPOCH) {
        // Task group retry is only available with ROLE-level retry policy.
        WorldId(format!("{}_attempt_{epoch}", world_id.name()))
    } else {
        world_id.clone()
    }
}

/// Write error message to MAST reply file.
fn write_error_to_reply_file_and_abort(error_message: &str, exit_code: i32) {
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();

    let reply_json = serde_json::json!({
        "message": error_message,
        "errorCode": exit_code,
        "timestamp": now.as_secs(),
        "timestamp_us": now.as_micros(),
    });

    match env::var(MAST_HPC_TASK_FAILURE_REPLY_FILE) {
        Ok(reply_file) => match File::create(Path::new(&reply_file)) {
            // Do not format the json using `to_vec_pretty`. MAST expects a one-line input.
            Ok(mut file) => match &serde_json::to_vec(&reply_json) {
                Ok(json_bytes) => {
                    if let Err(err) = file.write_all(json_bytes) {
                        tracing::error!("failed writing error to reply file with error {:?}", err);
                    }
                }
                Err(err) => tracing::error!("failed creating json reply file with error {:?}", err),
            },
            Err(err) => {
                tracing::error!("failed creating reply file with error {:?}", err);
            }
        },
        Err(err) => {
            tracing::error!(
                "reply file environment variable {} not set with error {:?}",
                MAST_HPC_TASK_FAILURE_REPLY_FILE,
                err
            );
        }
    }

    // Abort immediately.
    std::process::exit(exit_code);
}

// Returning Vec instead of map because of CLI argument parsing.
fn get_extra_labels(current_host: String) -> Vec<(String, String)> {
    let mut extra_labels = vec![(LABEL_NAME_HOST_NAME.to_string(), current_host.clone())];
    match FbWhoAmI::get() {
        Ok(fbwhoami) => {
            if let Some(ipv6_addr) = fbwhoami.primary_ipv6 {
                extra_labels.push((LABEL_NAME_IP_NAME.to_string(), ipv6_addr.to_string()));
            } else {
                tracing::warn!(
                    "no ipv6 address found in fbwhoami for host {}",
                    current_host
                );
            }
        }
        Err(err) => {
            tracing::warn!(
                "no ipv6 address found in fbwhoami for host {}: {}",
                current_host,
                err
            );
        }
    }
    extra_labels
}

#[cfg(test)]
mod tests {
    use std::fs::read_to_string;
    use std::future::Future;

    use nix::sys::wait::waitpid;
    use nix::unistd::ForkResult;
    use nix::unistd::fork;
    use tempfile::NamedTempFile;

    use super::*;

    async fn assert_termination_signal<F, Fut>(f: F) -> anyhow::Result<()>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = ()>,
    {
        // SAFETY: for unit test process assertion.
        unsafe {
            match fork() {
                Ok(ForkResult::Parent { child, .. }) => {
                    waitpid(child, None)?;
                    Ok(())
                }
                Ok(ForkResult::Child) => Ok(f().await),
                Err(_) => panic!("fork failed"),
            }
        }
    }

    #[tokio::test]
    async fn test_write_error_to_reply_file_and_abort() {
        let tmp_file = NamedTempFile::new().unwrap();
        let tmp_file_path = tmp_file.path().to_str().unwrap();
        env::set_var(MAST_HPC_TASK_FAILURE_REPLY_FILE, tmp_file_path);

        // We need to catch the process exit.
        let process = async {
            write_error_to_reply_file_and_abort("I'm two\nlines", 1);
        };
        assert_termination_signal(|| process).await.unwrap();

        let reply_file_contents = read_to_string(tmp_file_path).unwrap();
        let expected_reply_file_contents =
            "{\"message\":\"I'm two\\nlines\",\"errorCode\":1,\"timestamp\":0,\"timestamp_us\":0}"
                .to_string();

        // Remove timestamps as they can change
        let reply_file_contents: serde_json::Value =
            serde_json::from_str(&reply_file_contents).unwrap();
        let mut expected_reply_file_contents: serde_json::Value =
            serde_json::from_str(&expected_reply_file_contents).unwrap();

        expected_reply_file_contents["timestamp_us"] = reply_file_contents["timestamp_us"].clone();
        expected_reply_file_contents["timestamp"] = reply_file_contents["timestamp"].clone();
        assert_eq!(reply_file_contents, expected_reply_file_contents);
    }
}
